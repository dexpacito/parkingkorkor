"use strict";
// Copyright 2021 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOptions = exports.helpText = exports.OptionsError = void 0;
const minimist = require("minimist");
const path_1 = require("path");
const types_1 = require("./types");
/**
 * Error thrown when an invalid option is provided.
 */
class OptionsError extends Error {
}
exports.OptionsError = OptionsError;
/**
 * Helper class for parsing an configurable option from provided CLI flags
 * or environment variables.
 */
class ConfigurableOption {
    constructor(
    /**
     * The CLI flag that can be use to configure this option.
     */
    cliOption, 
    /**
     * The name of the environment variable used to configure this option.
     */
    envVar, 
    /**
     * The default value used when this option is not configured via a CLI flag
     * or environment variable.
     */
    defaultValue, 
    /**
     * A function used to valid the user provided value.
     */
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    validator = x => x) {
        this.cliOption = cliOption;
        this.envVar = envVar;
        this.defaultValue = defaultValue;
        this.validator = validator;
    }
    parse(cliArgs, envVars) {
        return this.validator(cliArgs[this.cliOption] || envVars[this.envVar] || this.defaultValue);
    }
}
const PortOption = new ConfigurableOption('port', 'PORT', '8080');
const FunctionTargetOption = new ConfigurableOption('target', 'FUNCTION_TARGET', 'function');
const SourceLocationOption = new ConfigurableOption('source', 'FUNCTION_SOURCE', '', path_1.resolve);
const SignatureOption = new ConfigurableOption('signature-type', 'FUNCTION_SIGNATURE_TYPE', 'http', x => {
    if ((0, types_1.isValidSignatureType)(x)) {
        return x;
    }
    throw new OptionsError(`Function signature type must be one of: ${types_1.SignatureType.join(', ')}.`);
});
exports.helpText = `Example usage:
  functions-framework --target=helloWorld --port=8080
Documentation:
  https://github.com/GoogleCloudPlatform/functions-framework-nodejs`;
/**
 * Parse the configurable framework options from the provided CLI arguments and
 * environment variables.
 * @param cliArgs the raw command line arguments
 * @param envVars the environment variables to parse options from
 * @returns the parsed options that should be used to configure the framework.
 */
const parseOptions = (cliArgs = process.argv, envVars = process.env) => {
    const argv = minimist(cliArgs, {
        string: [
            PortOption.cliOption,
            FunctionTargetOption.cliOption,
            SignatureOption.cliOption,
            SourceLocationOption.cliOption,
        ],
    });
    return {
        port: PortOption.parse(argv, envVars),
        target: FunctionTargetOption.parse(argv, envVars),
        sourceLocation: SourceLocationOption.parse(argv, envVars),
        signatureType: SignatureOption.parse(argv, envVars),
        printHelp: cliArgs[2] === '-h' || cliArgs[2] === '--help',
    };
};
exports.parseOptions = parseOptions;
//# sourceMappingURL=options.js.map